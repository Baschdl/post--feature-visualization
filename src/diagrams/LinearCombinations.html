<div class="linear-combinations">
  
  <div class="frow">
      
    <div class="fcolumn">
      <div class="icons">
        {{#each range(6) as i}}
          <div class="icon {{(x == i+1)? 'selected' : ''}}" on:click='set({x: i+1})'>
            <Sprite src_class={{sprite_class}} size=44 sprite_size=180 y=0 x={{i+1}} sprite_scale=0.5/>
          </div>
        {{/each}}
      </div>
    </div>
    
    <div class="fcolumn">
      <Sprite src_class={{sprite_class}} size=180 sprite_size=180 y=0 x={{x}} sprite_scale=1/>
    </div>
    
    <div class="operator">
      +
    </div>
    
    <div class="fcolumn">
      <Sprite src_class={{sprite_class}} size=180 sprite_size=180 y={{y}} x=0 sprite_scale=1/>
    </div>
  
    <div class="fcolumn">
      <div class="icons">
        {{#each range(6) as i}}
          <div class="icon {{(y == i+1)? 'selected' : ''}}" on:click='set({y: i+1})' >
            <Sprite src_class={{sprite_class}} size=44 sprite_size=180 y={{i+1}} x=0 sprite_scale=0.5/>
          </div>
        {{/each}}
      </div>
    </div>
    
  </div>
  

  
  <div class="frow">
    <!-- <figcaption id="caption">
      By jointly optimizing two neurons we can get a sense of how they interact.
    </figcaption> -->
    
    <div class="result c">
      <Sprite src_class={{sprite_class}} size=180 sprite_size=180 y={{y}} x={{x}} sprite_scale=1/>
    </div>
  </div>
  
</div>


<style>

  /* FRow & FColumn */

  .frow {
    display: flex;
    flex-flow: row;
    flex-wrap: wrap;
    justify-content: center;
  }

  .fcolumn {
    display: flex;
    flex-flow: column;
    margin-left: 10px;
    margin-right: 10px;
  }
  
  .fcolumn:first-of-type {
    margin-left: 0;
  }

  .fcolumn:last-of-type {
    margin-right: 0;
  }

  .fcolumn > * {
    margin-bottom: 10px;
  }

  .fcolumn > *:last-child {
    margin-bottom: 0;
  }

  /* -end FRow & FColumn end- */

 /* Icons */
  .icons {
    display: flex;
    flex-wrap: wrap;
    flex-direction: row;
    margin-bottom: 7px;
    margin-left: -3px;
    max-width: 100px;
  }

  .icons .icon {
    padding: 0px;
    background-color: #EEE;
    border: 3px solid white;
  }

  .icon div {
    filter: saturate(0%);
    image-rendering: auto;
  }

  .icon.selected div {
    filter: none;
  }

  .icons .selected {
    background-color: #AAA;
    border-color: #3497FF;
  }
  
  /* linear Combinations */

  .linear_combinations_sprite {
    background-image: url('images/linear_combinations.jpg')
  }

  
  #caption {
    max-width: 200px;
  }
  
  .result {
    align-self: center;
    position: relative;
    top: -51px;
    border: 2px solid white;
    box-shadow: 0px 5px 20px hsla(0,0%,0%,0.3);
  }
  
  .operator {
    display: flex;
    align-items: center;
    margin-right: 10px;
    margin-left: 10px;
    height: 180px;
  }

  
</style>


<script>
  import Sprite from './Sprite.html';
  // const join_svg = require('svg-inline-loader?classPrefix!../join.svg');
  
  function range(n){
    return Array(n).fill().map((_, i) => i);
  }

  export default {
    data() {
      return {
        sprite_class: 'linear_combinations_sprite',
        x: 5,
        y: 1,
        // svg: join_svg
      }
    },
    computed: {},
    components: {Sprite},
    methods: {},
    helpers: {range}
  }
</script>
